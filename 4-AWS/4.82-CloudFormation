=======================================================================
=======================================================================
YAML IS JUST A SUPERSET FOR JSON
 As a superset of JSON, a valid YAML file can contain JSON. Additionally, JSON can transform into YAML as well. YAML itself can also contain JSON in its configuration files.
=======================================================================
=======================================================================
I like to use an analogy comparing templates and stacks
to classes and objects in object-oriented programming.
So in object-oriented programming, you start with classes.
It's very similar to a template.
From a class you instantiate an object.
The object is a living,
breathing instantiation of that class.
So it's very similar.
So we start with a template
and from that template we can build our stack.
And again, a stack is a living,
breathing instantiation of that template.
Contained in that stack are all of our resources.
=======================================================================
Parameters:
• Parameters allow you to pass values into your template when you create a stack.
• Each Parameter specified must contain a value when you create a stack.
• Example Parameters: Instance Type, VPC ID, Subnet ID 
• Pseudo parameters are parameters that are predefined by AWS CloudFormation.
You do not declare them in your template. Use them the same way as you would a
parameter, as the argument for the Ref function.
• Pseudo Parameters:
AWS::Region
AWS::AccountId
AWS::NotificationARNs
AWS::NoValue
AWS::Partition
AWS::Stackld
AWS::StackName
AWS::URLSuffix
AWS..
Mappings:
Mappings match a key to a corresponding set of named values.
• A common use of Mappings is to map an instance type to an architecture or an AMI ID.

Conditions:
• Includes statements that define when a resource is created or when a property is defined.
• You might use Conditions when you want to reuse a template that can create different resources in different contexts.
• Example: Dev Environment vs Prod. You could use a Condition to deploy different sized instances based on the environment.
Smaller instances for Dev = cost savings.
• To use conditions, you need to incorporate 3 sections of the template: Parameters (what do you want to evaluate?), Condition,
and Resource or Output (the resource or output you want to conditionall create.

Transform:
Specifies one or more Transforms that CloudFormation uses to
process your template. You can simplify templates by condensing
and reusing template components.
• Two kinds of Transforms: AWS::ServerIess and AWS::IncIude
• Serverless refers to Lambda Functions - much more on that later!
• Includes are very much like includes in popular programming
languages. You can include code snippets in your template (reuse!)
=======================================================================

Very useful CloudFormation Snippets:
https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/CHAP_TemplateQuickRef.html


CLOUDFORMATION
Infrastructure as Code YAML/JSON
free to use , charged only for resources 
easy roll back 
manage updates and version control 
consistent 

AWSTemplateFormatVersion: "2010-09-09"
Description: "Template to create an EC2 Instance"
Metadata:
  Instances:
    Description: "Web Server Instance"

Parameters:  #input custom values
  EnvType:
    Description: "Environment type"
    Type: String
    AllowedValues:
      - prod
      - test 

Conditions: # provision resources based on environment
  CreateProdResources: !Equals [ !Ref EnvType, prod ]
  
Mappings: #e.g. create custom mappings based on a region 
  RegionMap:
    us-east-1:
      "ami": "ami-0453898e98046c639"

Transform: #include snippets of code outside the main template 
  Name: 'AWS::Include'
  Parameters:
    Location: 's3://MyAmazonS3BucketName/MyFileName.yml'

Resources: #the aws resources you are deploying <---------mendatory section
  EC2Instance:
    Type: AWS::EC2::Instance 
    Properties:
    Outputs:
  InstanceID:
    Description: the instance ID 
    Value: !Ref EC2Instance 
      InstanceType: t2.micro 
      ImageID: ami-0453898e98046c639





Template sections
Templates include several major sections. The Resources section is the only required section. Some sections in a template can be in any order. However, as you build your template, it can be helpful to use the logical order shown in the following list because values in one section might refer to values from a previous section.

Format Version (optional)
The AWS CloudFormation template version that the template conforms to. The template format version isn't the same as the API or WSDL version. The template format version can change independently of the API and WSDL versions.

Description (optional)
A text string that describes the template. This section must always follow the template format version section.

Metadata (optional)
Objects that provide additional information about the template.

Parameters (optional)
Values to pass to your template at runtime (when you create or update a stack). You can refer to parameters from the Resources and Outputs sections of the template.

Rules (optional)
Validates a parameter or a combination of parameters passed to a template during a stack creation or stack update.

Mappings (optional)
A mapping of keys and associated values that you can use to specify conditional parameter values, similar to a lookup table. You can match a key to a corresponding value by using the Fn::FindInMap intrinsic function in the Resources and Outputs sections.

Conditions (optional)
Conditions that control whether certain resources are created or whether certain resource properties are assigned a value during stack creation or update. For example, you could conditionally create a resource that depends on whether the stack is for a production or test environment.

Transform (optional)
For serverless applications (also referred to as Lambda-based applications), specifies the version of the AWS Serverless Application Model (AWS SAM) to use. When you specify a transform, you can use AWS SAM syntax to declare resources in your template. The model defines the syntax that you can use and how it's processed.

You can also use AWS::Include transforms to work with template snippets that are stored separately from the main AWS CloudFormation template. You can store your snippet files in an Amazon S3 bucket and then reuse the functions across multiple templates.

Resources (required)
Specifies the stack resources and their properties, such as an Amazon Elastic Compute Cloud instance or an Amazon Simple Storage Service bucket. You can refer to resources in the Resources and Outputs sections of the template.

Outputs (optional)
Describes the values that are returned whenever you view your stack's properties. For example, you can declare an output for an S3 bucket name and then call the aws cloudformation describe-stack'


Exporting CloudFormation Stack Values
EXPORT:

"Outputs" : {
    "VPCId" : {
      "Description" : "VPC ID",
      "Value" :  { "Ref" : "VPC" },
      "Export" : { "Name" : {"Fn::Sub": "${AWS::StackName}-VPCID" }}
    },
    "PublicSubnet" : {
      "Description" : "The subnet ID to use for public web servers",
      "Value" :  { "Ref" : "PublicSubnet" },
      "Export" : { "Name" : {"Fn::Sub": "${AWS::StackName}-SubnetID" }}
    },
    "WebServerSecurityGroup" : {
      "Description" : "The security group ID to use for public web servers",
      "Value" :  { "Fn::GetAtt" : ["WebServerSecurityGroup", "GroupId"] },
      "Export" : { "Name" : {"Fn::Sub": "${AWS::StackName}-SecurityGroupID" }}


IMPORT:

      "Resources": {
    "WebServerInstance": {
      "Type": "AWS::EC2::Instance",
      "Properties": {
        "InstanceType": "t3.micro",
        "ImageId": "ami-0889a44b331db0194",
        "NetworkInterfaces": [
          {
            "GroupSet": [
              {
                "Fn::ImportValue": {        <-----------------------------
                  "Fn::Sub": "${NetworkStackParameter}-SecurityGroupID" <--
                }
              }
            ],
            "AssociatePublicIpAddress": "true",
            "DeviceIndex": "0",
            "DeleteOnTermination": "true",
            "SubnetId": {
              "Fn::ImportValue": {      <---------------------------------
                "Fn::Sub": "${NetworkStackParameter}-SubnetID" <----------
    

---------------------------------------------------------------------------
https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/install-sam-cli.html

CloudFormation for Serverless 
Serverless Application Model (SAM) is an extension to CloudFormation used to define Serverless Applications 

SAM uses a simplified syntax for defining serverless resources:
$ sam package (packages your application and uploads to S3)
$ sam deploy (deploys your serverless app using CloudFormation)


Run all the commands using the AWS CloudShell, it already has the AWS CLI, SAM CLI installed. 

1) Copy hello-from-lambda.js and template.yml to the CloudShell:
curl -O https://raw.githubusercontent.com/ACloudGuru-Resources/course-aws-certified-developer-associate/main/CloudFormation_SAM_Demo/hello-from-lambda.js

curl -O https://raw.githubusercontent.com/ACloudGuru-Resources/course-aws-certified-developer-associate/main/CloudFormation_SAM_Demo/template.yml

2) Create an S3 bucket (add some random numbers to the bucket name to create a unique name):
aws s3 mb s3://cfsambucket

3) Package the files and save them to the S3 bucket you just created:
sam package --template-file template.yml --output-template-file sam-template.yml --s3-bucket cfsambucket

4) Deploy the code: 
sam deploy --template-file sam-template.yml --stack-name mystack --capabilities CAPABILITY_IAM

5) In the Lambda console, view the code, and test it. 



template.yml 
'# This is the SAM template that represents the architecture of your serverless application
# https://docs.aws.amazon.com/serverless-application-model/latest/developerguide/serverless-sam-template-basics.html

# The AWSTemplateFormatVersion identifies the capabilities of the template
# https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/format-version-structure.html
AWSTemplateFormatVersion: 2010-09-09
Description: >-
  sam-app

# Transform section specifies one or more macros that AWS CloudFormation uses to process your template
# https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/transform-section-structure.html
Transform:
- AWS::Serverless-2016-10-31

# Resources declares the AWS resources that you want to include in the stack
# https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/resources-section-structure.html
Resources:
  # Each Lambda function is defined by properties:
  # https://github.com/awslabs/serverless-application-model/blob/master/versions/2016-10-31.md#awsserverlessfunction

  # This is a Lambda function config associated with the source code: hello-from-lambda.js
  helloFromLambdaFunction:
    Type: AWS::Serverless::Function
    Properties:
      Handler: src/handlers/hello-from-lambda.helloFromLambdaHandler
      Runtime: nodejs18.x
      Architectures:
        - x86_64
      MemorySize: 128
      Timeout: 100
      Description: A Lambda function that returns a static string.
      Policies:
        # Give Lambda basic execution Permission to the helloFromLambda
        - AWSLambdaBasicExecutionRole'


---------------------------------------------------------------------------
CLOUDFORMATION - PREVENT STACK UPDATES 
you may want certain resources not to be updated.
preventing a stack-update could be to prevent data loss or interruption to service.
How? generate StackPolicy
StackPolicy:
A stack policy is a json document that defines the update actions that can be performed on designated resources.

{
  Statement : [
    {
      Effect : Deny,
      Action : Update:Replace,
      Principal: *,
      Condition : {
        StringEquals : {
          ResourceType : [AWS::DynamoDB::Table]
        }
      }
    },
    {
      Effect : Allow,
      Action : Update:*,
      Principal: *,
      Resource : *
    }
  ]
}
---------------------------------------------------------------------------
CF Nested Stacks 
nested stacks
allow you to reuse your CloudFormation code.
So for common use cases you dont need to copy and paste,
you can just reference the CloudFormation code
from within your CloudFormation template.
They are really useful for frequently used configurations.
So for example, for a frequently used configuration
for a load balancer, web server or application server.
And, all you need to do is create a CloudFormation template
defining the resource that you want to create,
store in S3 and then you can reference it
from the resources section of any CloudFormation template
using the stack resource type.

1-create modular templates (reusability)
2-assemble large templates (reduce complexity)

AWSTemplateFormatVersion: '2010-09-09'
Resources:
  myStack:
    Type: AWS::CloudFormation::Stack
    Properties:
      TemplateURL: https://s3.amazonaws.com/my-cfn/s3_bucket.template
      TimeoutInMinutes: '60'

---------------------------------------------------------------------------
CloudFormation Drift Detection 
Stack Actions -> Detect Drift 
what is drift?
drift is when your stack's actual configuration differs (has drifted) by what CF expects' 
when it happens?
when developer starts making manual ad-hoc changes to the stack (most common example is deleting resources manually which CF created)

DELETED, MODIFIED, NOT_CHECKED, IN_SYNC

---------------------------------------------------------------------------
CloudFormation Rollbacks
CF will attempt to rollback in case of an error put your stack to previous state.
Rollbacks are turned on by default. 
You can ignore rollbacks by using --ignore-rollback flag via AWS CLI

Sometimes, rollbacks can fail. then u have to investigate and change resource configuration or possibly need to reach out to 'paid aws support to resolve the failed rollback'

ROLLBACK_IN_PROGRESS
UPDATE_ROLLBACK_COMPLETE
UPDATE_ROLLBACK_FAILED

---------------------------------------------------------------------------
CloudFormation Psuedo Parameters 
parameters that are predefined by aws cloudformation 
you do not declare them in your template

use them the same way as you would a parameter, as the argument for the Ref function 

Outputs:
  MyStacksRegion:
    value: !Ref "AWS::Region"

AWS::Paertition returns the partition that resource is in
AWS::Region returns aws region in which resource is being created
AWS::StackId returns ID of stack as specified with aws CF 'create-stack'
AWS::StackName returns name of stack as specified wth aws CF 'create-stack'
AWS::URLSuffix  returns the suffix for the domain

---------------------------------------------------------------------------
CloudFormation Resource Attributes 

Creation Policy:
prevent stack status from reaching create complete until AWS cloudformation receives a specified number of success signals or the timeout period is exceeded 
---
Resources:
  Type: AWS::AutoScaling::AutoScalingGroup
  CreationPolicy:
    ResourceSignal:
      Count: 3
      Timeout: PT15M


Deletion Policy:
reserve or (in some cases) backup a resource when its stack is deleted 
Deleted, Retain, or Snapshot 
---
Resources:
  MyDbInstance:
    Type: AWS::RDS::DBInstance 
    DeletionPolicy: Snapshot


Update Policy:
How to handle an update for ASG, ElastiCache, Domain, or Lambda Alias
---
UpdatePolicy:
  AutoScalingReplacingUpdate:
    WillReplace: True


UpdateReplacePolicy:
what will happen when you update a stack, will it delete, retain or snapshot the existing resource instance 
Resources:
  MyDbInstance:
    Type: AWS::RDS::DBInstance 
    UpdateReplacePolicy: Retain

DependsOn:
the resource is created only after the creation of the resource specified in the DependsOn attribute 
Resources:
  MyEC2Instance:
    Type: AWS::EC2::Instance 
    DependsOn: MyDbInstance 
  MyDbInstance:
    Type: AWS::RDS::DBInstance


---------------------------------------------------------------------------
CloudFormation Intrinsic Functions 
use intrinsic functions in your templates to assign values to properties that are not available until runtime 
MOST IMPORTANT:
Fn::GetAtt returns the value of an attribute from a resource in template
Ref returns the value of a specified parameter or resource 
OTHERS:
Fn::Base64 - returns base64 representation of the input string 
Fn::Cidr - returns an array of CIDR address blocks 
*Condition Functons - Fn::And Fn::Or Fn::If Fn::Equals Fn::Not 
Fn::FindInMap - returns value corresponding to keys in a two-level map that is declared in the Mappings Section 
Fn::Transform - used with SAM, macro to perform custom processing on part of stack template 
Fn::GetAZs - returns an array that lists AZs for a specified region 
Fn::ImportValue - returns value of output exported by another stack 
Fn::Join - appends a set of values into a single value, separated by the specified delimiter
Fn::Split - split a string into a list of string values so that you can select an element from the resulting string list 
Fn::Select - returns a single object from a list of objects by index 
Fn::Sub - substitute variables in an input string with values that you specify

- - - - - - - - - - - - - - - - - - - - -
Ref & GetAtt
Ref returns different things for different resources 
yo need to lookup each resource in AWS Docs to see what it returns 
e.g. ARN, Resource Name, Physical ID
Ref can reference parameters or other defined resources 
When you need a value for a resource and can't get it from Ref,
    you can get it from Fn::GetAtt'
---
Resources:
  SecurityGroup: *
    Type: 'AWS::EC2::SecurityGroup'
    Properties:
      VPCId: !Ref VpcId
      GroupDescription: Enable HTTP and SSH access
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: !Ref LocationHTTP
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Ref LocationSSH
  WebServer:
    Type: 'AWS::EC2::Instance'
    Properties:
      Monitoring: false
      ImageId: !Ref ImageId
      InstanceType: !Ref InstanceType
      KeyName: !Ref KeyName 
      IamInstanceProfile: !Ref InstanceProfile 
      SecurityGroupIds:
        - !GetAtt SecurityGroup.GroupId **

* here is the resource we want to get value from 
** to get GroupId we use GetAtt on the resource
---------------------------------------------------------------------------
CloudFormation Wait Conditions 
wait conditions wait for a condition 
They are used in 2 cases:
1- to coordinate stack resource creation with configuration actions that are external to the stack creation 
2- to track the status of a configuration process 

WaitCondition is very similar to CreationPolicy-
AWS recommends using CreationPolicy for EC2 and ASG 

- CreationPolicy waits on the dependent resource 
- WaitCondition waits on the wait condition (external)

WebServerGroup:
  Type: AWS::AutoScaling:AutoScalingGroup
  Properties:
    AvailabilityZones:
      Fn::GetAZs: ""
    LaunchConfigurationName:
      Ref: "LaunchConfig"
    MinSize: "1"
    MaxSize: "5"
    DesiredCapacity:
      Ref: "WebServerCapacity"
    LoadBalancerNames:
      Ref: "ElasticLoadBalancer"

WaitHandle:
  Type: AWS::CloudFormation::WaitConditionHandle
WaitCondition:
  Type: AWS::CloudFormation::WaitCondition
  Dependson: "WebServerGroup"
  Properties:
    Handle:
      Ref: "WaitHandle"
    Timeout: "300"
    Count: 
      Ref: "WebServerCapacity"

--------------------------------------------------------------------------

WRITE TEMPLATE 
AWSTemplateFormatVersion: 2010-09-09
Description: >-
  Infrastructure for StudySync
Parameters:
  ImageId:
    Description: AMI to use
    Default: ami-0f409bae3775dc8e5
    Type: String
  VpcID:
    Description: the VPC used by SG
    Default: vpc-0a58795060b0ac716
    Type: String
Resources:
  WebServer:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: t2.micro
      ImageId: !Ref ImageId
      SecurityGroupIds: 
        - !GetAtt SecurityGroup.GroupId  
        //this is how you connect Instance with security group
  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcID
      GroupDescription: "open port 80"
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: "0.0.0.0/0"
          


npm i cfn-lint -g
rupert:~/environment/cloudformation $ cfn-lint validate template.yaml 
0 infos
0 warn
0 crit
Template valid!


AUTOMATE - update.sh
#!/bin/bash
aws s3 cp template.yaml s3://reasoncf329/template.yaml
aws cloudformation update-stack \
--region us-east-1 \
--stack-name studysync \
--template-url https://reasoncf329.s3.amazonaws.com/template.yaml \
--parameters \
ParameterKey=VpcID,ParameterValue=vpc-0a58795060b0ac716


rupert:~/environment/cloudformation $ aws cloudformation list-stack-resources --stack-name StudySync
{
    "StackResourceSummaries": [
        {
            "LogicalResourceId": "SecurityGroup",
            "PhysicalResourceId": "sg-03c28b7e4902ff1d5",
            "ResourceType": "AWS::EC2::SecurityGroup",
            "LastUpdatedTimestamp": "2023-08-31T16:41:05.449000+00:00",
            "ResourceStatus": "CREATE_COMPLETE",
            "DriftInformation": {
                "StackResourceDriftStatus": "NOT_CHECKED"
            }
        },
        {
            "LogicalResourceId": "WebServer",
            "PhysicalResourceId": "i-00d118c5182393ea4",
            "ResourceType": "AWS::EC2::Instance",
            "LastUpdatedTimestamp": "2023-08-31T17:43:57.563000+00:00",
            "ResourceStatus": "UPDATE_COMPLETE",
            "DriftInformation": {
                "StackResourceDriftStatus": "NOT_CHECKED"
            }
        }
    ]
}
rupert:~/environment/cloudformation $ 

rupert:~/environment/cloudformation $ aws ec2 describe-instances --instance-ids i-00d118c5182393ea4
   "SecurityGroups": [
                        {
                            "GroupName": "StudySync-SecurityGroup-12TZEI0B5T9X7",
                            "GroupId": "sg-03c28b7e4902ff1d5"
                        }
                    ],

it matches!


now to install webserver on the instance, provide a script as UserData

AWSTemplateFormatVersion: 2010-09-09
Description: >-
  Infrastructure for StudySync
Parameters:
  ImageId:
    Description: AMI to use
    Default: ami-0f409bae3775dc8e5
    Type: String
  VpcID:
    Description: the VPC used by SG
    Default: vpc-0a58795060b0ac716
    Type: String
Resources:
  WebServer:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: t2.micro
      ImageId: !Ref ImageId
      SecurityGroupIds: 
        - !GetAtt SecurityGroup.GroupId
      UserData:
        'Fn::Base64':
          !Sub |
          #!/usr/bin/env bash
          yum update -y
          su ec2-user
          sudo yum install httpd -y
          sudo systemctl enable --now httpd
  SecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Properties:
      VpcId: !Ref VpcID
      GroupDescription: "open port 80"
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 80
          ToPort: 80
          CidrIp: "0.0.0.0/0"
Outputs:
  PublicIps:
    Value: !GetAtt WebServer.PublicIp

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

----------------------------------------------------------------------

AWS CLOUDFORMATION SAM

SAM is both an AWS CLI tool and a cloudformation Macro which makes it effortless to define and deploy serverless application 


What is Macro?
A Macro allows you to change the rules on how code works, allowing you to embed a language with a language.
Macros serve to make code more human readable or allow to write less code.
Creating a language within another language is called a DSL (Domain Specific Language) and by using Macros, you are creating a DSL

CloudFormation allows you to specify Macros through the Transform attribute. This is how SAM is used

Transform: 'AWS::Serverless-2016-10-31'

SAM gives you new resource types 
AWS::Serverless::Function 
AWS::Serverless::API
AWS::Serverless::SimpleTable

You write atleast 50% less Code with SAM
--- --- --- --- --- --- --- --- --- ---
AWSTemplateFormatVersion: '2010-09-09'
Transform: 'AWS::Serverless-2016-10-31'
Resources:
  MyApi:
    Type: AWS::Serverless::Api 
    Properties:
      Name: MyApi 
      StageName: prod 
      EndpointConfiguration: REGIONAL 
      Cors:
        AllowMethods: "'Get,POST,OPTIONS'"
        AllowHeaders: "'Content-Type,X-Api-Key,X-Amz-Security-Token'"
        AllowOrigin: "'*'"
  ArticlesIndex: 
    Type: 'AWS::serverless::Function'
    Properties:
      Runtime: nodejs16.x
      Handler: index.handler 
      CodeUri: s3://my-app/functions/articles.index.zip 
      MemorySize: 128
      Timeout: 10
      AutoPublishAlias: live 
      DeploymentPreference: 
        Type: AllAtOnce 
      Events:
        Post:
          Type: Api
          Properties:
            Path: /
            Method: Get 
            RestApiId:
              Ref: MyApi 
      Policies: 
        - AWSLambdaExecute //managed policy 
        - AWSLambdaVPCAccessExecutionRole 
        - Version: '2012-10-17' //policy-document 
          Statement:
            - Effect: Allow 
              Action:
                - secretsmanager:GetSecretValue 
                - secretsmanager:PutResourcePolicy
                - secretsmanager:PutSecretValue
                - secretsmanager:DeleteSecret 
                - secretsmanager:DescribeSecret 
                - secretsmanagers:TagResource 
                - secretsmanager:CreateSecret 
                - secretsmanager:ListSecret 
                - secretsmanager:GetRandomPassword
                - tag:GetResources
                - rds-data:BatchExecutionStatement
                - rds-data:BeginTransaction
                - rds-data:CommitTransaction
                - rds-data:ExecuteStatement
                - rds-data:RollbackTransaction


SAM CLI -----
sam build - prepare lambda source code to be deployed by packaging it
sam deploy - upload lambda package code 
sam init - initialize a new serverless project
sam local generate-event 
sam local invoke - run a single lambda locally
sam local start-api -- run your serverless application locally for testing
sam local start-lambda -- run a single lambda locally
sam logs 
sam package - packages aws SAM application
sam publish - publishes your packaged SAM application 
sam validate - validates aws SAM template 

=======================================================================
Careful with Your Data
• S3 buckets in a stack must be emptied first
before they can be deleted as part of the
stack delete.
• Some resources offer a deletion policy
(Retain, Delete, Snapshot) that allows you
to specify what to do with a resource when
stack is deleted.

Resources that support Snapshots:
AWS::EC2::Volume
AWS::ElastiCache::CacheCluster
AWS::ElastiCache::ReplicationGroup
AWS::Neptune::DBCluster
AWS::RDS::DBCluster
AWS::RDS::DBInstance
AWS::Redshift::Cluster

=======================================================================
LIMITS
Resources-200 resources-Maximum resources per template.
Stacks-200 stacks (soft)-Maximum stacks per AWS account.
Parameters-60 parameters-Maximum parameters per template.
Outputs-60 outputs-Maximum resources per template.
Custom resource reponse-4,096 bytes-Maximum data that a custom resource provider can pass.



===================================================================
SAM
sam init -> template -> hello world
cd MyApi
sam build
$ sam deploy --guided

Configuring SAM deploy
======================

        Looking for config file [samconfig.toml] :  Not found

        Setting default arguments for 'sam deploy'
        =========================================
        Stack Name [sam-app]: MyApiStack
        AWS Region [us-east-1]: 
        #Shows you resources changes to be deployed and require a 'Y' to initiate deploy
        Confirm changes before deploy [y/N]: y
        #SAM needs permission to be able to create roles to connect to the resources in your template
        Allow SAM CLI IAM role creation [Y/n]: y
        #Preserves the state of previously provisioned resources when an operation fails
        Disable rollback [y/N]: n
        HelloWorldFunction may not have authorization defined, Is this okay? [y/N]: y
        Save arguments to configuration file [Y/n]: y
        SAM configuration file [samconfig.toml]: 
        SAM configuration environment [default]: 

deploy? y


in app.py...change this setting to deploy update to function Canary style

      Runtime: python3.7
      AutoPublishAlias: live    <--------
      DeploymentPreference:     <--------
        Type: Canary10Percent5Minutes <--
      Architectures:
        - x86_64

sam validate
sam build
sam deploy



===========================================================================================================
You are using CloudFormation to build a number of different application environments to host development, test, UAT, pre-production, and production stacks. Your application is comprised of web servers, load balancers, application servers, and databases. Each web server, load balancer, and database needs to be configured identically across all environments. You would also like to reduce the duplication of code to avoid mistakes caused by human error. How can you achieve this with CloudFormation?

Use a CloudFormation nested stack.```````````````````````````````

Nested stacks provide the ability to configure multiple elements within your environment while reducing duplication of code. As your infrastructure grows, common patterns can emerge in which you declare the same components in multiple templates. You can separate out these common components and create dedicated templates for them. Then, use the resource in your template to reference other templates, creating nested stacks.

Reference: Nested Stacks to Create Reusable Templates

Copy and paste the configuration code that you want to reuse into the CloudFormation template for each environment.

Use the Mappings section of the template to reference the code you want to reuse.

The Mappings section of a CloudFormation template is used to match a key to a corresponding set of named values. For example, if you want to set values based on a Region, you can create a mapping that uses the Region name as a key and contains the values you want to specify for each specific Region. Mappings cannot be used to reduce the duplication of code when you need to provision components like web servers, load balancers, application servers, and databases that need to be configured identically across all environments.

Selected
Use environment variables.

===========================================================================================================
A developer uses AWS SAM templates to deploy a serverless application. He needs to embed the application from the AWS Serverless Application Repository or from an S3 bucket as a nested application.

Which of the following resource type is the most SUITABLE one that the developer should use?


AWS::Serverless::Function

AWS::Serverless::LayerVersion

AWS::Serverless::Api

AWS::Serverless::Application
Incorrect
A serverless application can include one or more nested applications. You can deploy a nested application as a stand-alone artifact or as a component of a larger application.

As serverless architectures grow, common patterns emerge in which the same components are defined in multiple application templates. You can now separate out common patterns as dedicated applications, and then nest them as part of new or existing application templates. With nested applications, you can stay more focused on the business logic that’s unique to your application.

==================================================================================================================
Category: CDA – Development with AWS Services
A development team has started using AWS CloudFormation for deploying Lambda functions. Their project structure places the source code for the Lambda function locally within a directory named “tutorialsdojo”. The lambda handler for the function is in a file called “app.js”.

Below is a snippet of their template.

Transform: AWS: : Serverless-2016-10-31
Resources :
  TutorialsDojoFunction :
    Type: AWS: : Serverless: : Function
    Properties :
      Handler: app.lambdaHand1er
      Role: arn:aws: iam: : 123456789012: role/execution role
      CodeUri : tutorialsdojo/
      Runtime : nodejs14.x
      Timeout : 15


What is the next step in order for the template to be deployed using the aws cloudformation deploy CLI?


Upload the app.js file to an S3 bucket. Update the CodeUri property in the template to point to the S3 URI of the file.

Use the aws cloudformation package command to upload the local artifacts of the Lambda function to an S3 bucket and produce a version of the template with references to the S3 URI of the file.```````````````````````````````

Package the Lambda function in a ZIP file. Specify the local path of the packaged file in the CodeUri property.

Use the Fn::Base64 intrinsic function inline with the CodeUri property to encode the content of the app.js file.



The aws cloudformation package command packages the local artifacts (local paths) that your AWS CloudFormation template references. The command uploads local artifacts, such as source code for an AWS Lambda function or a Swagger file for an AWS API Gateway REST API, to an S3 bucket. The command returns a copy of your template, replacing references to local artifacts with the S3 location where the command uploaded the artifacts.

Use this command to quickly upload local artifacts that might be required by your template. After you package your template’s artifacts, run the aws cloudformation deploy command to deploy the returned template.

Since we have local artifacts (source code for the AWS Lambda functions), we should use the package command.
E:\Sandbox\P.E aws cloudformation package \
--template-file tdojo_template.yml \
--s3-bucket lakas-pilipinas \
--output-template-file tdojo_packaged .yml


===============================================================================================================
An application architect manages several AWS accounts for staging, testing, and production environments, which are used by several development teams. For application deployments, the developers use the similar base CloudFormation template for their applications.

Which of the following can allow the developer to effectively manage the updates on this template across all AWS accounts with minimal effort?

Upload the CloudFormation templates to CodeCommit and use a combination of CodeDeploy and CodePipeline to manage the deployment to multiple accounts.
Create and manage stacks on multiple AWS accounts using CloudFormation Change Sets.
Update the stacks on multiple AWS accounts using CloudFormation StackSets.`````````````````````````````````````
Define and manage stack instances on multiple AWS Accounts using CloudFormation Stack Instances.


Incorrect
AWS CloudFormation StackSets extends the functionality of stacks by enabling you to create, update, or delete stacks across multiple accounts and regions with a single operation. Using an administrator account, you define and manage an AWS CloudFormation template, and use the template as the basis for provisioning stacks into selected target accounts across specified regions.



A stack set lets you create stacks in AWS accounts across regions by using a single AWS CloudFormation template. All the resources included in each stack are defined by the stack set’s AWS CloudFormation template. As you create the stack set, you specify the template to use, as well as any parameters and capabilities that the template requires.

Hence, the correct solution in this scenario is to update the stacks on multiple AWS accounts using CloudFormation StackSets.



After you’ve defined a stack set, you can create, update, or delete stacks in the target accounts and regions you specify. When you create, update, or delete stacks, you can also specify operational preferences, such as the order of regions in which you want the operation to be performed, the failure tolerance beyond which stack operations stop, and the number of accounts in which operations are performed on stacks concurrently. Remember that a stack set is a regional resource so if you create a stack set in one region, you cannot see it or change it in other regions.

Creating and managing stacks on multiple AWS accounts using CloudFormation Change Sets is incorrect because Change Sets only allow you to preview how proposed changes to a stack might impact your running resources. In this scenario, the most suitable way to meet the requirement is to use StackSets.

Defining and managing stack instances on multiple AWS Accounts using CloudFormation Stack Instances is incorrect because a stack instance is simply a reference to a stack in a target account within a region. Remember that a stack instance is associated with one stack set which is why this is just one of the components of CloudFormation StackSets.

Uploading the CloudFormation templates to CodeCommit and using a combination of CodeDeploy and CodePipeline to manage the deployment to multiple accounts is incorrect. Although using a combination of CodeCommit, CodePipeline, and CodeDeploy might work, this entails a lot of manual work and additional overhead. It is better to use the CloudFormation StackSets instead to be able to update the templates across all AWS accounts with minimal effort.

===================================================================================================================
An aerospace engineering company has recently migrated to AWS for their cloud architecture. They are using CloudFormation and AWS SAM as deployment services for both of their monolithic and serverless applications. There is a new requirement where you have to dynamically install packages, create files, and start services on your EC2 instances upon the deployment of the application stack using CloudFormation.

Which of the following helper scripts should you use in this scenario?

cfn-signal
cfn-hup
cfn-init````````````````````````
cfn-get-metadata
Incorrect
AWS CloudFormation provides the following Python helper scripts that you can use to install software and start services on an Amazon EC2 instance that you create as part of your stack:

cfn-init: Use to retrieve and interpret resource metadata, install packages, create files, and start services.

cfn-signal: Use to signal with a CreationPolicy or WaitCondition, so you can synchronize other resources in the stack when the prerequisite resource or application is ready.

cfn-get-metadata: Use to retrieve metadata for a resource or path to a specific key.

cfn-hup: Use to check for updates to metadata and execute custom hooks when changes are detected.

You call the scripts directly from your template. The scripts work in conjunction with resource metadata that’s defined in the same template. The scripts run on the Amazon EC2 instance during the stack creation process. The scripts are not executed by default. You must include calls in your template to execute specific helper scripts.



Hence, cfn-init helper script is the correct answer since it interprets the metadata that contains the sources, packages, files, and services. You run the script on the EC2 instance when it is launched. The script is installed by default on Amazon Linux and Windows AMIs.

The cfn-get-metadata helper script is incorrect since it is only a wrapper script that retrieves either all metadata that is defined for a resource or path to a specific key or a subtree of the resource metadata, but does not interpret the resource metadata, install packages, create files, and start services.

The cfn-signal helper script is incorrect since it does not perform any retrieval and interpretation of resource metadata, installation of packages, creation of files, and starting of services. Instead, it is a wrapper thats signals an AWS CloudFormation WaitCondition for synchronizing other resources in the stack when the application is ready.

The cfn-hup helper script is incorrect because this is just a daemon that checks for updates to metadata and executes custom hooks when changes are detected. It does not retrieve and interpret the resource metadata, install packages, create files, and start services unlike cfn-init helper script.

===============================================================================================================
A development team has recently completed building their serverless application, and they are now ready to deploy it to AWS. They need to zip their code artifacts, upload them to Amazon S3, and produce the package template file for deployment.

Which command is the MOST suitable to use for automating the deployment steps?


sam package

sam deploy````````````````

sam publish

aws cloudformation deploy
Incorrect
AWS SAM uses AWS CloudFormation as the underlying deployment mechanism. You can deploy your application by using AWS SAM command line interface (CLI) commands. You can also use other AWS services that integrate with AWS SAM to automate your deployments.

After you develop and test your serverless application locally, you can package and deploy your application by using the sam deploy command.



The sam deploy command zips your code artifacts, uploads them to Amazon S3, and produces a packaged AWS SAM template file that it uses to deploy your application.

To deploy an application that contains one or more nested applications, you must include the CAPABILITY_AUTO_EXPAND capability in the sam deploy command.

Hence, the correct answer is: sam deploy

aws cloudformation deploy is incorrect. While this command can be used to deploy a CloudFormation stack, it expects that your artifacts are already packaged and uploaded to S3. It doesn’t handle the packaging process implicitly.

sam package is incorrect. This command prepares the serverless application for deployment by zipping artifacts, uploading them to S3, and generating a CloudFormation template with references to the uploaded artifacts in S3. It doesn’t deploy the application.

sam publish is incorrect because this command publishes an AWS SAM application to the AWS Serverless Application Repository, and does not generate the template file. It takes a packaged AWS SAM template and publishes the application to the specified region.
==============================================================================================================
	
An application is hosted in the us-east-1 region. The app needs to be recreated on the us-east-2, ap-northeast-1, and ap-southeast-1 region using the same Amazon Machine Image (AMI). As the developer, you have to use AWS CloudFormation to rebuild the application using a template.

Which of the following actions is the most suitable way to configure the CloudFormation template for the scenario?

(view)	1	0	1	00:01:04	
 Copy the AMI of the instance from the us-east-1 region to the us-east-2, ap-northeast-1, and ap-southeast-1 region. Then, add a Mappings section wherein you will define the different Image Id for the three regions. Use the region name as the key in mapping to its correct Image Id. Lastly, use the Fn::ImportValue function to retrieve the desired Image Id from the region key.

 'Copy the AMI of the instance from the us-east-1 region to the us-east-2, ap-northeast-1, and ap-southeast-1 region. Then, add a Mappings section wherein you will define the different Image Id for the three regions. Use the region name as the key in mapping to its correct Image Id. Lastly, use the Fn::FindInMap function to retrieve the desired Image Id from the region key.'

 Copy the AMI of the instance from the us-east-1 region to the us-east-2, ap-northeast-1, and ap-southeast-1 region. Then, add a Mappings section wherein you will define the different Image Id for the three regions. Use the region name as the key in mapping to its correct Image Id. Lastly, use the Fn::GetAtt function to retrieve the desired Image Id from the region key.

 Copy the AMI of the instance from the us-east-1 region to the us-east-2, ap-northeast-1, and ap-southeast-1 region. Then, add a Parameters section wherein you will define the different Image Id for the three regions. Use the region name as the key in mapping to its correct Image Id. Lastly, use the Ref function to retrieve the desired Image Id from the region key.