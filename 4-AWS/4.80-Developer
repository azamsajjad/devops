CodeCommit
CodeDeploy
CodePipeline
CodeBuild
CodeArtifact
Elastic Container Service 
CloudFormation 
--sam 
--nested stacks 
Cloud Development Kit 
Amplify 


---------------------------------------
CODE  >   BUILD   >   INTEGRATE   >   TEST  >   RELEASE   >   DEPLOY .
^---CI-automatically reviews code-------^
^---CDelivery-auto preparing code 4 release--------^
^---CDeployment-auto deploy code as soon as pushed---------------^
----------------------------------------

CI/CD 
Small incremental changes
it all starts with 
CI Shared Code Repository: CodeCommit (Private Source and Version Control)
CDEL Automated Build: CodeBuild (produces packages)
Automated Test:
Code is Merged
Prepared for Deployment:
CD Continous Delivery - Manual Delivery:
CD Continous Deployment - Automated Delivery: CodeDeploy (on EC2,Lambda)
CDEP Managing Entire Workflow: CodePipeline (end-to-end)

"CodeCommit" Repository:
store source code, binaries, libraries - allows input from multiple sources
same as git 
create user to use as [aws configure] - with CodeCommitFullAccess
create access key IAM
    $aws configure
create git key from IAM to be used for 
    $aws codecommit create-repository --repository-name devopsfromcli
    username:
    password:

AWSLabsUser-uEWJyTWcmNB6kw66NbeLv:~/environment $ cd appfn/
AWSLabsUser-uEWJyTWcmNB6kw66NbeLv:~/environment/appfn $ aws codecommit create-repository --repository-name appfn
{
    "repositoryMetadata": {
        "accountId": "582908443542",
        "repositoryId": "5ceee032-4b85-41c1-8b77-911da11b43e0",
        "repositoryName": "appfn",
        "lastModifiedDate": "2023-10-09T10:23:13.330000+00:00",
        "creationDate": "2023-10-09T10:23:13.330000+00:00",
        "cloneUrlHttp": "https://git-codecommit.us-east-1.amazonaws.com/v1/repos/appfn",
        "cloneUrlSsh": "ssh://git-codecommit.us-east-1.amazonaws.com/v1/repos/appfn",
        "Arn": "arn:aws:codecommit:us-east-1:582908443542:appfn"
    }
}
AWSLabsUser-uEWJyTWcmNB6kw66NbeLv:~/environment/appfn $ git config --global credential.helper '!aws codecommit credential-helper $@'
AWSLabsUser-uEWJyTWcmNB6kw66NbeLv:~/environment/appfn $ git config --global credential.UseHttpPath true
AWSLabsUser-uEWJyTWcmNB6kw66NbeLv:~/environment/appfn $ git config --global init.defaultBranch main
AWSLabsUser-uEWJyTWcmNB6kw66NbeLv:~/environment/appfn $ 
AWSLabsUser-uEWJyTWcmNB6kw66NbeLv:~/environment/appfn $ git init
Initialized empty Git repository in /home/ec2-user/environment/appfn/.git/
AWSLabsUser-uEWJyTWcmNB6kw66NbeLv:~/environment/appfn (main) $ git add .
AWSLabsUser-uEWJyTWcmNB6kw66NbeLv:~/environment/appfn (main) $ git commit -m "first commit"
AWSLabsUser-uEWJyTWcmNB6kw66NbeLv:~/environment/appfn (main) $ git remote add origin https://git-codecommit.us-east-1.amazonaws.com/v1/repos/appfn
AWSLabsUser-uEWJyTWcmNB6kw66NbeLv:~/environment/appfn (main) $ git push -u origin main
---------------------------------------------------------------------------
"CodeDeploy":
2 deployment approaches -
in-place deployment : rolling update - app stopped on each instance one by one and is updated.
if you change your mind after deployment, no easy fix, redeploy old version
no lambda support

blue-green deployment : new release installed on new instances 
blue(active) 
green(new release)
u pay for 2 environments - old and new uptil you switch and delete old
CodeDeploy install the new verion as "REVISION"

CodeDeploy AppSpec File 
configuration file with parameters which will be used during CodeDeploy deployment
for EC2 and on-premise systems - YAML only 
Lambda based deployment with ec2 - YAML or JSON
AppSpec file structure 
   - version 
   - OS
   - files (define location of app files)
   - hooks (lifecycle event hoosts) (scripts) e.g. unzip, run tests, to deal with re-register and re-register instances with a load balancer
Typical Folder Setup (root)
appspec.yml     /Scripts   /Config     /Source
---
version: 0.0
os: linux 
files: 
    - source: /
      destination: /home/ec2-user/app
permissions:
    - object: /home/ec2-user/app 
      owner: ec2-user
      group: ec2-user
hooks:
  ApplicationStop: 
    - location: aws/deployment/application_stop/stop_app.sh
      timeout: 20
      runas: ec2-user
  BeforeInstall:
    - location: Scripts/unzipresourcebundle
    - location: Scripts/unzipdatabundle
  AfterInstall:
    - location: Scripts/unzipdatabundle
      timeout: 100
  ApplicationStart:
    - location: aws/deployment/application_start/start_app.sh
      timeout: 20
      runas: ec2-user
  ValidateService:
    - location: Scripts/unzipdatabundle
      timeout: 3600
      runas: ec2-user
...

LifecycleEventHooks:
run in specific order (RUN-ORDER)
BeforeBlockTraffic
phase1 : de-register instances from a Load Balancer - BlockTraffic
AfterBlockTraffic
phase2 : real nuts and bolts of application deployment - ApplicationStop
DownloadBundle
BeforeInstall
Install 
AfterInstall 
ApplicationStart
ValidateService
BeforeAllowTraffic
phase3 : re-register instances from a Load Balancer - AllowTraffic 
AfterAllowTraffic



All hooks are available for in-place deployment instances
B/G deployment - original: before,blockTraffic,after AVL only
B/G deployment - replaced: before,blockTraffic,after NOT but all

B/G deployment rollback - original: before,AllowTraffic,after AVL only
B/G deployment rollback - replaced: before,BlockTraffic,after AVL only



To Set Up CodeDeploy:
you need CodeDeploy Agent and ServiceRole on your EC2 Instance 
CD Agent: so EC2 can report back to CodeDeploy 
CD Srole: create a CodeDeploy ServiceRole based on your deployment strategy




CREATE AN EC2 instance with following role -have access to Sessions Manager
SSMEC2ServiceRole with policy AmazonEC2RoleforSSM
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Effect": "Allow",
            "Action": [
                "sts:AssumeRole"
            ],
            "Principal": {
                "Service": [
                    "ec2.amazonaws.com"
                ]
            }
        }
    ]
}


USERDATA:
#!/bin/bash
su ec2-user
sudo yum install httpd -y 
sudo chown ec2-user:ec2-user -R /var/www
cat > /var/www/html/index.html <<EOL
<html>
<head>
<title>My Code Deploy App</title>
</head>
<body>
<h1>My Code Deploy App</h1>
</body>
</html>
EOL
sudo systemctl --enable now httpd




version: 0.0
os: linux
files:
    - source: /
      destination: /var/www/html
permissions:
    - object: /var/www
      owner: ec2-user
      group: ec2-user 
hooks:
  AfterInstall:
    - location: /update_app.sh 
      timeout: 6
      runas: ec2-user
  ApplicationStart: 
    - location: /restart_app.sh 
      timeout: 6
      runas: ec2-user

restart_app.sh
sudo systemctl restart /usr/sbin/httpd
update_app.sh     
rm /var/www/html/index.html
cp /revision/index.html /var/www/html/index.html



 184  git clone https://git-codecommit.us-east-1.amazonaws.com/v1/repos/my-code-deploy-app
  185  cd my-code-deploy-app/
  186  which zip
  187  zip revision-v2.zip appspec.yml index.html restart_app.sh update_app.sh 
  188  aws s3api create-bucket --bucket-name my-code-deploy-329 --region us-east-1
  189  aws s3api create-bucket --bucket my-code-deploy-329 --region us-east-1
  190  aws s3 cp revision.zip s3://my-code-deploy-329/revisions/v2.zip
  191  aws s3 cp revision-v2.zip s3://my-code-deploy-329/revisions/v2.zip


CodeDeploy -> Create Application -> Create Deployment
attach this role in Create Deployment (first create it)
AWSCodeDeployRole
with Policy
AWSCodeDeployRole	AWS managed	Permissions policy
create deployment 


lab failed b/c i didnt install codedeploy agent on the instance
---------------------------------------------------------------------------
"CodePipeline" CI/CD Service
Workflow is defined 
workflow begins when there is a change detected in your source code 
automatic trigger pipeline 
integrates with aws and 3rd party tools such as jenkins 

LAB 
1) To create your EC2 instance using CloudFormation, first save CF_Template.json to your own S3 bucket, 
then update the command below to reference your bucket as well as the name of a Key pair that you own in the 
region that you are working in. 

WINDOWS users will need to use ^ (Shift + 6) instead of \ for line continuation.

aws cloudformation create-stack --stack-name CodeDeployDemoStack \
--template-url https://cloudformation12329.s3.amazonaws.com/CF_Template.json \
--parameters ParameterKey=InstanceCount,ParameterValue=1 \
ParameterKey=InstanceType,ParameterValue=t2.micro \
ParameterKey=KeyPairName,ParameterValue=ams \
ParameterKey=OperatingSystem,ParameterValue=Linux \
ParameterKey=SSHLocation,ParameterValue=0.0.0.0/0 \
ParameterKey=TagKey,ParameterValue=Name \
ParameterKey=TagValue,ParameterValue=CodeDeployDemo \
--capabilities CAPABILITY_IAM

2) Verify that the Cloud Formation stack has completed using: 
aws cloudformation describe-stacks --stack-name CodeDeployDemoStack --query "Stacks[0].StackStatus" --output text

3) Log in to your instance (created by CF) and check that the CodeDeploy agent has correctly installed:  
sudo service codedeploy-agent status
or
sudo systemctl status codedeploy-agent

4) Create another S3 bucket and upload version 1 of your code 
dont forget to enable Versioning on your S3 bucket
5) go to codedeploy and deploy your code stored in s3 bucket 
6) go to codepipeline and create a pipeline 
7) uploaded version 2 of code to s3 -> automatically deployed by pipeline 


--------------------------------------------
LAB 
Our lab use case involves solving a pending problem with our code deployment pipeline. There have been a series of deployments that resulted in unexpected downtime to our client's web application. There have been cases where our QA team did not approve source code before being deployed to the production environment. Our management team has instructed our DevOps team to implement an approval process to keep this from reoccurring. Our solution is to build an AWS CodePipeline pipeline and add a stage that requires manual approval before deploying the source code to production.

Luckily, AWS CodePipeline enables us to easily implement a manual approval process. In this lab, we will build an AWS CodePipeline pipeline that will deploy a web application. We will build in a stage with a manual approval action right after the code repository and before the deployment stage.'

1-Create an AWS IAM Role

In order to allow CloudFormation to act on our behalf, it is necessary to create an IAM role for CloudFormation. You will need to navigate to Identity and Access Management (IAM) and create a role. This role can be granted AdministratorAccess for the purposes of this lab, but keep in mind the principle of least privilege in a production environment.


2-Create an AWS CodeCommit Repository and SNS Topic

Create a CodeCommit respository and upload the s3Retain.yaml file from the GitHub repository. You will also need to create a Simple Notification Service (SNS) topic and subscription using an email to which you have access in order to setup the manual approval for this lab.


3-Create an AWS CodePipeline Pipeline

Create an AWS CodePipeline pipeline with a source provider of AWS CodeCommit using the repository that was created in the previous objective. Make sure to skip the build stage since we'll be using code from AWS CodeCommit instead of building within the pipeline. In the deploy stage, you will need to deploy a CloudFormation stack with the Identity and Access Management (IAM) role that was created earlier. Once the pipeline has been deployed, modify the pipeline by implementing a manual approval step and go through the process of deploying the pipeline again. Observe the notification in your email and then approve the change in the AWS console.

---------------------------------------------------------------------------
"CodeStar" 
Welcome to the AWS CodeStar sample static HTML website
This sample code helps get you started with a simple static HTML website deployed by AWS CodeDeploy and AWS CloudFormation to an Amazon EC2 instance.

What's Here
This sample includes:

README.md - this file
appspec.yml - this file is used by AWS CodeDeploy when deploying the website to EC2
scripts/ - this directory contains scripts used by AWS CodeDeploy when installing and deploying your website on the Amazon EC2 instance
webpage/ - this directory contains static web assets used by your website
index.html - this file contains the sample website
template.yml - this file contains the description of AWS resources used by AWS CloudFormation to deploy your infrastructure
template-configuration.json - this file contains the project ARN with placeholders used for tagging resources with the project ID

---------------------------------------------------------------------------
CODEBUILD - use for code testing
- A fully managed build service in the cloud 
- Compiles your source code, runs unit tests, produces artifacts that are ready to deploy 
- eliminates the need to provision, manage, and scale your own build servers 
- provides pre-packaged build environments for popular programming languages and build tools such as Apache Maven, Gradle, and more 
- scales automatically to meet peak build requests 

- BUILDSPEC.YML CAN BE OVER-RIDDEN WITH CLI COMMANDS .
                                        Source Provider
                                        buildspec.yml
AWS Console                        |--------------------|
AWS CLI          --> CodeBuild --> | Build Project      |--> Build Artifact
AWS SDK                            |====================|--> notify SNS
AWS CodePipeline                   | Build Environment  |
                                   |____________________|
                                    build environments uses 
                                    docker.
                                    you can use AWS Managed images
                                    or
                                    your own Custom Docker Image      
Common UseCase1:
A website built with Gatsby needs to render out static pages and delivery for S3 static website hosting
AWS Console -> CodeCommit -> CodeBuild -> Render Static Files -> S3 Bucket
                Gatsby                           Gatsby


Common UseCase2:
A developer needs to ensure their code passes all tests before being allowed to make a pull request 
Github -> Github Webhook -> Lambda using AWS SDK -> CodeBuild -> Testing
 Ruby app                                                      run RSPEC


"Buildspec.yml file" needs to be at root - provides build instructions

version: 0.2
phases: 
  install:
    commands: 
      - bundle install 
  pre_build:
    commands:
      - service postgresql start 
      - export DATABASE_CLEANER_ALLOW_REMOTE_DATABASE_URL=true 
      - export RAILS_ENV=test 
  build:
    commands:
      - bundle exec rake db:create 
      - bundle exec rake db:schema:load 
      - bundle exec rake db:migrate
  post_build:
    commands:
      - bundle exec rspec 
      - bundle exec cucumber
= = = = = = = = = = == = = = = = = = = = = = = = = = = = = = = = == = = =
version 0.1 runs each build command in a separate instance 
0.2 runs in the same instance



---------------------------------------------------------------------------
CodeArtifact
an artifact repository makes it easy for developers to find the software packages they need 
securely store, publish, share packages 
a packag is a bundle of software
includes software from open source
it integrates with publics repos such as npm registry for node.js,
python package index, maven central for commonly used libraries 
it integrates with CodeBuild

CodeArtifact
        my-domain__________________________________   External Connection
        |    Repository  <->  Upstream Repository  |-> Public Repo
        |    my-repos    <->  npn-store            |-> NPM registry
        -------------------------------------------
Create a Domain 
Add an External Connection 
Associate the Upstream Repo 
Install a Package using npm cli

1) Create a domain:
aws codeartifact create-domain --domain my-domain

2) Create a repository in your domain:
aws codeartifact create-repository --domain my-domain --repository my-repo

3) Create an upstream repository for your my-repo repository:
aws codeartifact create-repository --domain my-domain --repository npm-store

4) Add an external connection to the npm public repository to your npm-store repository:
aws codeartifact associate-external-connection --domain my-domain --repository npm-store --external-connection "public:npmjs"

5) Associate the npm-store repository as an upstream repository to the my-repo repository:
aws codeartifact update-repository --repository my-repo --domain my-domain --upstreams repositoryName=npm-store

6) Configure the npm package manager with your my-repo repository (fetches an authorization token from CodeArtifact using your AWS credentials):
aws codeartifact login --tool npm --repository my-repo --domain my-domain

7) Use the npm CLI to install an npm package. For example, to install the popular npm package express, use the following command, if we don’t specify a version, this command will install the latest version available in the external repo:
npm install express

(express is a Node.js web application framework used to develop web and mobile applications)

8) View the package you just installed in your my-repo repository:
aws codeartifact list-packages --domain my-domain --repository my-repo


You now have three CodeArtifact resources:
* The domain my-domain.
* The repository my-repo that is contained in my-domain. This repository has an npm package available to it.
* The repository npm-store that is contained in my-domain. This repository has an external connection to the public npm repository and is associated as an upstream repository with the my-repo repository.

9) To avoid further AWS charges, delete the resources you created:
aws codeartifact delete-repository --domain my-domain --repository my-repo
aws codeartifact delete-repository --domain my-domain --repository npm-store
aws codeartifact delete-domain --domain my-domain
---------------------------------------------------------------------------
Elastic Container Service 
ECS will run your containers on clusters of virtual machines
linux containers and windows containers 
it uses Fargate for serverless
https://12factor.net/
https://d1.awsstatic.com/whitepapers/DevOps/running-containerized-microservices-on-aws.pdf

https://docs.aws.amazon.com/AmazonECR/latest/userguide/docker-push-ecr-image.html

https://docs.aws.amazon.com/AmazonECR/latest/userguide/getting-started-cli.html

$sudo amazon-linux-extras install docker
$sudo service docker start
$sudo usermod -a -G docker ec2-user
Log out and log back in again to pick up the new docker group permissions. You can accomplish this by closing your current SSH terminal window and reconnecting to your instance in a new one. Your new SSH session will have the appropriate docker group permissions.

Verify that the ec2-user can run Docker commands without sudo.


$docker info
Step 1: Create a Docker image
$touch Dockerfile
        FROM public.ecr.aws/docker/library/ubuntu:18.04

        # Install dependencies
        RUN apt-get update && \
        apt-get -y install apache2

        # Install apache and write hello world message
        RUN echo 'Hello World!' > /var/www/html/index.html

        # Configure apache
        RUN echo '. /etc/apache2/envvars' > /root/run_apache.sh && \
        echo 'mkdir -p /var/run/apache2' >> /root/run_apache.sh && \
        echo 'mkdir -p /var/lock/apache2' >> /root/run_apache.sh && \ 
        echo '/usr/sbin/apache2 -D FOREGROUND' >> /root/run_apache.sh && \ 
        chmod 755 /root/run_apache.sh

        EXPOSE 80

        CMD /root/run_apache.sh


Build the Docker image from your Dockerfile.
$docker build -t hello-world .
Run docker images to verify that the image was created correctly.
$docker images --filter reference=hello-world
$docker run -t -i -p 80:80 hello-world
$docker-machine ip machine-name


Step 2: Authenticate to your default registry
After you have installed and configured the AWS CLI, authenticate the Docker CLI to your default registry. That way, the docker command can push and pull images with Amazon ECR. The AWS CLI provides a get-login-password command to simplify the authentication process.
$aws ecr get-login-password --region region | docker login --username AWS --password-stdin aws_account_id.dkr.ecr.region.amazonaws.com

Get-ECRLoginCommand (AWS Tools for Windows PowerShell)
(Get-ECRLoginCommand).Password | docker login --username AWS --password-stdin aws_account_id.dkr.ecr.region.amazonaws.com



Step 3: Create a repository
Now that you have an image to push to Amazon ECR, you must create a repository to hold it. In this example, you create a repository called hello-repository to which you later push the hello-world:latest image. To create a repository, run the following command:
aws ecr create-repository \
    --repository-name hello-repository \
    --image-scanning-configuration scanOnPush=true \
    --region region

Step 4: Push an image to Amazon ECR
PUSH
To tag and push an image to Amazon ECR
List the images you have stored locally to identify the image to tag and push.

$docker images
$docker tag hello-world:latest aws_account_id.dkr.ecr.region.amazonaws.com/hello-repository
$docker push aws_account_id.dkr.ecr.region.amazonaws.com/hello-repository

Step 5: Pull an image from Amazon ECR
PULL
docker pull aws_account_id.dkr.ecr.region.amazonaws.com/hello-repository:latest

DELETE
aws ecr batch-delete-image \
      --repository-name hello-repository \
      --image-ids imageTag=latest \
      --region region

"DELETE REPO" ECR: elastic container registry
aws ecr delete-repository \
      --repository-name hello-repository \
      --force \
      --region region


---------------------------------------------------------------------------


-----------------------------------------------------------------------
CDK Cloud Development Kit :
Well, its an open-source development framework
which allows you to build applications,
define and deploy AWS resources
all using a programming language of your choice.
And the ones that are supported,
for instance, TypeScript, Python, Java, .NET, and Go.


First, you need to create a new CDK project,
so we run 
--$cdk init -> inside an empty directory.
--$npm run build -> to compile your application.
--$cdk synth -> to create a CloudFormation template,
and it's synthesizing a new CloudFormation template
based on the code you've provided.
And then, finally, deploy your stack.
--$cdk deploy -> to deploy the stack using CloudFormation.


Run all commands using the CloudShell: 
1. Install the latest version of the CDK, and update to the latest version of TypeScript. :
sudo npm install -g aws-cdk
sudo npm update -g typescript

2. Initialize a sample app using a language of our choice - e.g. typescript. :
mkdir myapp
cd myapp
cdk init sample-app --language=typescript



3. Check your files have been successfully created, the following files should be present in your directory: bin  cdk.json  jest.config.js  lib  node_modules  package.json  package-lock.json  README.md  test  tsconfig.json
The file that contains the details of the stack and its constructs is lib/cdk-init-stack.ts. The cdk.json file tells CDK how to execute your app : 
ls

4. Manually compile the app:
npm run build
cdk ls (to check - the name of our app’s directory is the name of the stack)

5. Synthesise a CloudFormation template:
cdk synth

(It stores the template in cdk.out folder)

6. Deploy the stack: 
(Before we deploy we need to run the bootstrap commend. This is to provision required resources for CDK before we can deploy CDK apps into an AWS account and Region - an S3 bucket to store files and IAM roles with permission to perform deployments.)

cdk bootstrap 
cdk deploy


7. In the console, check CloudFormation, review our stack - there should be an SQS Queue, and an SNS Topic. 


---------------------------------------------------------------------------
AMPLIFY 
Amplify helps people who are primarily
front-end developers to create full stack web
and mobile applications on AWS.
It includes libraries that integrate
with Cognito, S3, Lambda
and API Gateway to create a reliable backend.

And you've got two different services.
So firstly, you've got 
1- Amplify Hosting 
(auto update website when change in code is detected)
which gives you static website hosting that integrates
with your code repository for CICD functionality
and 
2- Amplify Studio, which provides a simple visual tool
and it can be used to configure the front end
and backend of your application.


-----------------------------------------------------------
Q
Which of the following are suitable to store in CodeArtifact?


Compiled applications
All of these are suitable
Deployable packages
Libraries
Documentation relating to your application

CodeArtifact is a fully managed artifact repository service that makes it easy for organizations of any size to securely store, publish, and share software packages used in their software development process. This includes everything needed to build your application, including libraries, deployable packages, compiled applications, and documentation relating to your application.


Q 
How can you prevent AWS CloudFormation from deleting successfully provisioned resources during a stack create operation, while allowing resources in a failed state to be updated or deleted upon the next stack operation?

Choose 2


`Use the --enable-termination-protection flag with the AWS CLI
`Set Termination Protection to Enabled in the CloudFormation console
`In the CloudFormation console, for Stack failure options, select "Preserve successfully provisioned resources"
`Use the "--disable-rollback" flag with the AWS CLI

Sorry!
This AWS CLI option keeps the stack unchanged if a user attempts to delete it.

This AWS CloudFormation console option keeps the stack unchanged if a user attempts to delete it.

Correct Answer
Create operations set to "Preserve successfully provisioned resources" preserves the state of successful resources, while failed resources will stay in a failed state until the next update operation is performed. Stack failure options.

Specifying the disable-rollback option or on-failure DO_NOTHING enumeration during a create-stack operation will preserve successfully provisioned resources during a stack create operation. Stack failure options.


----------------------------------------
Q 
Part of your CloudFormation deployment fails due to a misconfiguration, by default what will happen?


CloudFormation will ask you if you want to continue with the deployment
CloudFormation will rollback only the failed components
CloudFormation will rollback the entire stack
Failed components will remain available for debugging purposes

Good work!
Correct. By default, the “automatic rollback on error” feature is enabled. This will direct CloudFormation to only create or update all resources in your stack if all individual operations succeed. If they do not, CloudFormation reverts the stack to the last known stable configuration.

-------------------------------------------------------
Which AWS service can be used to compile source code, run tests and also package code?
CodeDeploy
CodeCommit
CodePipeline
CodeBuild

Good work!
Correct. CodeBuild is a fully managed continuous integration service that compiles source code, runs tests, and produces software packages that are ready to deploy.
-------------------------------------------------------
In AWS CloudFormation, which top-level section of the donor stack's CloudFormation template would you use to declare the output values that you want to use as inputs for another CloudFormation stack (the recipient stack)?

Resources
Export
Outputs
Transforms

Sorry!
The Resources section defines the resources you are provisioning.

Correct Answer
The Outputs section is used to output user-defined data relating to the resources you have built. You can also use the Export field within the Outputs section to export values to be used as input for another CloudFormation stack.
------------------------------------------------------
You are running your application using Docker provisioned with Elastic Beanstalk. You would like to upgrade the application to a new version. How should you approach this?


Create a new Docker image using the latest code, deploy it using Elastic Beanstalk, then terminate your old environment.


Create a new Docker image using the latest code, log in to the underlying EC2 instance and install the new Docker image.


Bundle your Dockerfile and the application code into a zip file, then upload and deploy it using the Elastic Beanstalk console.


Bundle your code into a zip file, upload and deploy it using Cloud Formation.

Good work!
Elastic Beanstalk supports the deployment of web applications as Docker containers. Each time you upload a new version of your application with the Elastic Beanstalk console or the EB CLI, Elastic Beanstalk creates an application version. When using the console you can choose to upload and deploy your code in a single step. Elastic Beanstalk will manage the previous version of your code so you can revert back to it if necessary.
-------------------------------------------------------
You want users to receive an email notification whenever they push code to their AWS CodeCommit repositories. How can you configure this?


Configure Notifications in the AWS CodeCommit console, this will create a CloudWatch Events rule to send a notification to an Amazon SNS topic which will trigger an email to be sent to the user


Configure a CloudWatch Events rule to send a message to SQS which will trigger an email to be sent whenever a user pushes code to the repository


Configure a CloudWatch Events rule to send a message to SES which will trigger an email to be sent whenever a user pushes code to the repository


Create a new SNS topic and configure it to poll for CodeCommit events. Ask all your users subscribe to the topic to receive notifications

Sorry!
Incorrect. CodeCommit can use a trigger to send events to Amazon SNS, but Amazon SNS cant poll for CodeCommit events.

Correct Answer
Correct. You can set up notification rules for a repository so that repository users receive emails about the repository event types you specify. Notifications are sent when events match the notification rule settings. You can create an Amazon SNS topic to use for notifications or use an existing one in your AWS account. You can use the CodeCommit console and the AWS CLI to configure notification rules.
-------------------------------------------------------

A developer wants to use CodeBuild to set up continuous integration for their project. They would like to ensure the project is integrated with the latest code and that the DevOps team is automatically notified of a failure in the build process by receiving an SMS message. Which of the following should the developer implement?

Use the CodePipeline dashboard to view the CodeBuild events log.

Use CloudWatch Events and SES notifications to send a message to the DevOps team.

Add the name of the email group to the notifications section of the CodeBuild console.

The CodeBuild console does not enable you to configure notifications in this way.

Selected
Store the source code in EFS.

Store the source code in CodeCommit.````````````````

CodeCommit is a supported source code repository for CodeBuild.

Reference: CodeBuild Project Source Repository Types

Selected
Use CloudWatch Events and an SNS topic to notify subscribers of build events.````````````````````````

CodeBuild natively supports CloudWatch Events; SNS is a subscription-based notification service that integrates with CloudWatch.


=======================================================================
A developer wants to deploy an AWS Serverless Application Model (AWS SAM) application with the AWS SAM CLI. The developer is using the AWS CLI in an AWS Cloud9 environment for deployment and has run the sam build command to prepare the application for deployment. The next day, the developer connects to the same AWS Cloud9 environment and attempts to deploy the application. The sam deploy command returns the following error:

Invalid (or missing) template file (path must be workspace-relative, or absolute)


How can the developer resolve this error?

Report Content Errors

A
Rename the template.yaml file that was created by the sam build command to deploy.yaml.

B
Place the template.yaml file that was created by the sam build command into the .deploy directory.

C`````````````````````````
Change the working directory to the root of the AWS SAM application.

D
Reinitialize the AWS SAM application with the sam init comment.


==================================================================================================
You are using CodeBuild to build the source code for your new application and would like to reference a large number of environment variables in buildspec.yml. However, when you try to run the build, you see an error telling you that the parameters you have specified have exceeded the number of characters allowed by the buildspec file. You need to find an alternative way to store these parameters. Which of the following options would you recommend?


Store the variables as dependencies within the application code.


Store the variables as key-value pairs in DynamoDB.


Use Systems Manager Parameter Store.`````````


Store the variables as key-value pairs in S3.

===================================================================================================
A developer is building a new feature for an application deployed on an EC2 instance in the N. Virginia region. A co-developer suggests to upload the code on Amazon S3 and use CodeDeploy to deploy the new version of the application. The deployment fails during the DownloadBundle deployment lifecycle event with the UnknownError: not opened for reading error.

What is the possible cause of this?

(view)	1	0	1	00:01:11	
 Wrong configuration of the DownloadBundle lifecycle event in the AppSec file.
 The DownloadBundle deployment lifecycle event is not supported in the N. Virginia region.
 /The EC2 instance’s IAM profile does not have the permissions to access the application code in Amazon S3./
 Versioning is not enabled on the Amazon S3 Bucket where the application code resides.
An EC2/On-Premises deployment hook is executed once per deployment to an instance. You can specify one or more scripts to run in a hook. Each hook for a lifecycle event is specified with a string on a separate line. Here are descriptions of the hooks available for use in your AppSpec file.



DownloadBundle deployment lifecycle event will throw an error whenever:

- The EC2 instance’s IAM profile does not have permission to access the application code in the Amazon S3.

- An Amazon S3 internal error occurs.

- The instances you deploy to are associated with one AWS Region (for example, US West Oregon), but the Amazon S3 bucket that contains the application revision is related to another AWS Region (for example, US East N. Virginia).

Hence, the correct answer is: The EC2 instance’s IAM profile does not have the permissions to access the application code in Amazon S3.

The option that says: Wrong configuration of the DownloadBundle lifecycle event in the AppSec file is incorrect because you can not manually configure DownloadBundle in the Appsec file. The CodeDeploy Agent installed on the EC2 instance manages the DownloadBundle lifecycle event.

The option that says: The DownloadBundle deployment lifecycle event is not supported in the N. Virginia region is incorrect because CodeDeploy is supported in N. Virginia.

The option that says: Versioning is not enabled on the Amazon S3 Bucket where the application code resides is incorrect because versioning on Amazon S3 Bucket is just used to preserve, retrieve, and restore every version of every object stored in your Amazon S3 bucket.

==================================================================================================================
	
A company uses AWS CodeDeploy in their CI/CD pipeline to handle in-place deployments of their web application on EC2 instances. Recently, a new version of the application was pushed, which contained a code regression. The deployment group is configured with automatic rollback.

What happens if the deployment of the new version fails?

(view)	1	0	1	00:01:38	
 /CodeDeploy redeploys the last known good version of an application with a new deployment ID./
 CodeDeploy pauses the current deployment, restores the last stable version from S3, and uses the deployment ID of the most recent deployment with a SUCCEEDED status.
 CodeDeploy reroutes traffic back to the blue environment and terminates the green environment.
 CodeDeploy reverts the EC2 instance to a previous AMI snapshot taken during the last successful deployment.




 	
A development team needs to deploy an application revision into three environments: Test, Staging, and Production. The application should be deployed into the Test environment first, then Staging, and then Production.

Which approach will conveniently allow the team to deploy the application into different environments?

(view)	1	1	0	00:00:51	
 /Create multiple deployment groups for each environment using AWS CodeDeploy./
 Create a repository for each environment in AWS CodeCommit to deploy the application.
 Create, configure, and deploy multiple application projects for each environment using CodeBuild.
 Create multiple data pipeline provisions for each environment to deploy the application using the AWS Data Pipeline.



 CodeDeploy provides two deployment type options:

In-place deployment: The application on each instance in the deployment group is stopped, the latest application revision is installed, and the new version of the application is started and validated. You can use a load balancer so that each instance is deregistered during its deployment and then restored to service after the deployment is complete. Only deployments that use the EC2/On-Premises compute platform can use in-place deployments. AWS Lambda compute platform deployments cannot use an in-place deployment type.

Blue/green deployment: The behavior of your deployment depends on which compute platform you use:

– Blue/green on an EC2/On-Premises compute platform: The instances in a deployment group (the original environment) are replaced by a different set of instances (the replacement environment). If you use an EC2/On-Premises compute platform, be aware that blue/green deployments work with Amazon EC2 instances only.

– Blue/green on an AWS Lambda compute platform: Traffic is shifted from your current serverless environment to one with your updated Lambda function versions. You can specify Lambda functions that perform validation tests and choose the way in which the traffic shift occurs. All AWS Lambda compute platform deployments are blue/green deployments. For this reason, you do not need to specify a deployment type.

– Blue/green on an Amazon ECS compute platform: Traffic is shifted from the task set with the original version of a containerized application in an Amazon ECS service to a replacement task set in the same service. The protocol and port of a specified load balancer listener are used to reroute production traffic. During deployment, a test listener can be used to serve traffic to the replacement task set while validation tests are run.

The CodeDeploy agent is a software package that, when installed and configured on an instance, makes it possible for that instance to be used in CodeDeploy deployments. The CodeDeploy agent communicates outbound using HTTPS over port 443.

It is also important to note that the CodeDeploy agent is required only if you deploy to an EC2/On-Premises compute platform. The agent is not required for deployments that use the Amazon ECS or AWS Lambda compute platform.




The current application deployment process of a company is tedious and is prone to errors. They asked a developer to set up CodeDeploy as their deployment service, which can automate their application deployments on their hybrid cloud architecture.

Which of the following deployment types does CodeDeploy support? (Select TWO.)

Rolling deployments to ECS.
In-place deployments to on-premises servers``````````````
Blue/green deployments to ECS.```````````````````````````
In-place deployments to AWS Lambda.
Blue/green deployments to on-premises servers.
Correct
CodeDeploy is a deployment service that automates application deployments to Amazon EC2 instances, on-premises instances, serverless Lambda functions, or Amazon ECS services.