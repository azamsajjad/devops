FEATURES:
The application is packaged so that you control the application and all associated resources, such as policies, security, and deployment.


bullet
Containers are portable and can be moved to different OS or hardware platforms, and through different environments such as development, testing/staging, pre-production, and production.


bullet
There are no time-out limits when running. This is useful for applications that run longer than 15 minutes or that need to initiate instantly when called.


bullet
Containers run without the startup latency of Lambda or Amazon EC2.


bullet
Containers have no size limit. They can be as large or as small as you need them to be.


bullet
Containers are useful when taking a large traditional application and breaking it down into small parts, or microservices, to make the application more scaleable and resilient. 





===============================================================
When to consider containers

For compute-intensive workloads
Applications that are compute intensive run better in a container environment. If you have a small application that runs under in 15 minutes but is compute intensive, consider using a container. Lambda is not the best fit for a heavily compute-intensive piece of code.

For large monolithic applications 
These are appropriate candidates to move to containers. Large monoliths that have many parts are very suitable applications to consider moving to containers. 
You can break apart applications and run them as independent components, called microservices, using containers to isolate processes.
By using microservices, you can break large applications into smaller, self-contained pieces. 
Segmenting a larger application means that updates can be applied on only specific parts. Because each part of the larger application resides in its own container, an update that might have affected files used by a different piece of the application is isolated to its own container.

With containers, you can do frequent updates by pushing out new containers, without the concern that one set of updates might break another part of the application. If you detect any issues, you have the flexibility to undo the change quickly.

When you need to scale quickly 
Containers can be built and taken down quickly, which means fast application deployment and scaling.

When you need to move your large application to the cloud without altering the code 

With containers, you can package entire applications and move them to the cloud without the need to make any code changes. 

Your application can be as large as you need it to be and can run as long as you require it to run.






When not to use containers

When applications need persistent data storage 
Containers can absolutely support persistent storage; however, it tends to be easier to containerize applications that don't require persistent storage. Persistent storage requirements increase the security and storage complexity and also make the containers less portable. If the container is moved, the storage needs to be reconfigured and secured.

Applications that have no state information and don't require complex persistent storage would be better candidates for using a container solution than an application with complex storage needs.


When applications have complex networking, routing, or security requirements
Containers are portable and can be moved through different environments (testing, staging, production). If the application requires a complex configuration for networking, routing, storage, and so on, the containers are much more challenging to move.
===============================================================
=     Auto Scaling Group 
=
=
= -----------------------------------------------------------
= |                       ECS CLUSTER                       |
= |    _____________________    _____________________       |
= |   |    EC2 Container    |  |   EC2 Container     |      |
= |   | task1 task2 service |  |  service1 service2  |      |
= |   |_____________________|  |_____________________|      |
= |---------------------------------------------------------|
=
=
===============================================================
Cluster = Multiple EC2 instances which will house docker containers
Task Definition = JSON file tht defines configuration of upto 10 containers
EC2 Container = EC2 Instances with mulriple Docker Containers
Tasks = one-off job ( just like BuildFile in EB)
Service = Long-running jobs (like ProcFile)
Container Agent = Binary on each EC2 which monitors, start & stop tasks 

CLUSTER TYPES: 
1-ECS Clusters
2-Fargate (serverless and you can create empty cluster)

OPTIONS:
Spot or on Demand
EC2 Instance Type 
No. of Instances 
EBS Storage Volumes
EC2 can be aws Linux 1 or 2
VPC, IAM Role, CloudWatch, Key Pair , SSH into container is not rec. by aws




==========================================
IAM
"ecsInstanceRole" with policy:
AmazonEC2ContainerServiceforEC2Role
==========================================
Task execution IAM role
This role is required by tasks to pull container images and publish container logs to Amazon CloudWatch on your behalf. If you do not have the ecsTaskExecutionRole already, we can create one for you.

Use cases for other AWS services:

Elastic Container Service
Allows ECS to create and manage AWS resources on your behalf.


---->Elastic Container Service Task
Allows ECS tasks to call AWS services on your behalf.

AmazonECSTaskExecutionRolePolicy
===========================================
IAM -> CloudShell
aws iam create-service-linked-role --aws-service-name ecs.amazonaws.com
===========================================
IAM -> CloudShell
aws iam create-service-linked-role --aws-service-name autoscaling.amazonaws.com
===========================================
IAM
'ECS CodeDeploy Role: Before you can use the CodeDeploy blue/green deployment type with Amazon ECS, the CodeDeploy service needs permissions to update your Amazon ECS service on your behalf. These permissions are provided by the CodeDeploy IAM role.

To create the ecsCodeDeployRole IAM role

Open the IAM console 
In the navigation pane, choose Roles, Create role.
Choose the AWS service role type, and then choose CodeDeploy.
Choose the CodeDeploy use case and then Next: Permissions.
For Role Name, type ecsCodeDeployRole and choose Create role.
Open ecsCodeDeployRole` role again from IAM console , to add the required additional permissions.
Choose Attach policies.
To narrow the available policies to attach, for Filter, type AWSCodeDeployRoleForECS
Check the box to the left of the AWS managed policy and choose Attach policy and Update.'
===========================================
Error in Creating Task Definition
IAM
IAM Create Policy and attach it to Rupert
{
    "Version": "2012-10-17",
    "Statement": [
        {
            "Sid": "VisualEditor0",
            "Effect": "Allow",
            "Action": "iam:PassRole",
            "Resource": "*"
        }
    ]
}
=============================================
Create Cluster
Create Task Definition = JSON file tht defines configuration of upto 10 containers
Create Container
Create Service on the Container
------------------------------------------------------------

FARGATE 
you have VPC and subnet in Fargate (serverless) too
Same as EC2, apply Security Group at Task Level
You can apply IAM role at Task level too


                FARGATE         vs          LAMBDA      
Cold Starts     yes(shorter)                yes 
Duration        As long as you want         15 min (max)
Memory          upto 30gb                   upto 3gb 
Containers      you provide ur own cont     limited to standard cont 
Integrations    More Manual Labour          seamless integration with aws
Pricing         atleast 1 min and every     pay per 100ms
                additional second   



=========================================================================
In Amazon ECS, the machine that runs the containers is an EC2 instance that has an ECS agent installed and configured to run and manage your containers. This instance is called a container instance. In Amazon EKS, the machine that runs the containers is called a worker node or Kubernetes node. 

An ECS container is called a task. An EKS container is called a pod.


Amazon ECS runs on AWS native technology. Amazon EKS runs on Kubernetes. 