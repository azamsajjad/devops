7- Create Ansible plays and playbooks:
Know how to work with commonly used Ansible modules
Use variables to retrieve the results of running a command
Use conditionals to control play execution
Configure error handling
Create playbooks to configure systems to a specified state



ansible-playbook --ask-become-pass play.yml

CLOUD_GURU_LAB1
Install httpd on the webserver group.
Start the httpd service on the webserver group.
Create a dba account on the dbserver group.
Copy /root/DBAstuff.txt to the new user's home directory. Make sure he is the owner and group of the file, set permissions to 0600.
Create index.html in /var/www/html on the webserver.
Use the git module to check out https://github.com/ansible/ansible.git on the Admin server - put it in the /opt directory.


--
- name: for lab
  hosts: webservers
  become: true
  tasks:
    - name: install httpd
      yum:
        name: httpd
        state: present
    - name: start httpd
      service:
        name: httpd
        state: started
        enabled: yes
    - name: configure index.html
      copy:
        content: "This is a webpage."
        dest: /var/www/html/index.html
- name: for dbservers
  hosts: dbservers
  become: true
  tasks:
    - name: add a user
      user:
        name: dba
        state: present
    - name: copy a file
      copy:
        src: /root/DBAstuff.txt
        dest: /home/dba/DBAstuff.txt
        owner: dba
        group: dba
        mode: 0600
- name: for admins
  hosts: admins
  become: true
  tasks:
    - name: git set up
      yum:
        name: git
        state: present
    - name: clone git repo
      git:
        repo: 'https://github.com/ansible/ansible.git'
        dest: /opt



CLOUD_GURU_LAB2
Notice: Ansible is installed as the root user, so please work on all tasks after elevating to the root user.
Our backup team wants us to install their backup package everywhere in the environment, and make sure that there's an archive file for them to back up, even if it's empty.
We know that the backup team's repository server has a very low uptime. We need to write our playbook so that installing the linuxacademy_backup_package will not cause the entire playbook to fail. In addition, we have to check and make sure that /root/archive.tar exists, and then create it if it doesn't.
---
- name: install package and check archive file
  hosts: all
  tasks:
    - name: install required package
      yum:
        name: linuxacademy_backup_package
        state: present
      ignore_errors: yes
    - name: check if file exists
      command: ls /root/archive.tar
      register: check_result
      ignore_errors: yes
    - name: create archive file
      file:
        path: /root/archive.tar
        state: touch
      when: check_result is failed
~


CLOUD_GURU_LAB3
Management has just told us they bought 300 servers, and we've been tasked with writing a playbook to get them ready to go as quickly as possible. They've already had the OS installed and configured to work with our Ansible environment.

We need to write a single playbook that will run and make sure that all the servers involved are correctly configured and in the desired state when it's finished running. We also need to ensure that all commands are idempotent.

Install the linuxacademy-backup-software package throughout our environment. Due to the high potential for this repository server to be unavailable, ensure a failure doesn't stop the playbook from running.
Install httpd on the webserver group.
Start and enable the httpd service on the webserver group.
Create a dba account on the dbserver group.
Copy /root/DBAstuff.txt to the new user's home directory. Make sure that user (and the group with the same name) owns the file, and set permissions to 0600.
Create index.html in /var/www/html on the web server.
Ensure index.html on the web servers contains the line "Waiting for content."
Install git on the webserver and dbserver group if it is not already.
On each Red Hat server, create a file (/root/addresses) that contains all of the IPv4 addresses for the server.

---
- name: for webservers
  hosts: webservers
  become: true
  tasks:
    - name: install httpd
      yum:
        name: httpd
        state: present
    - name: enable httpd
      service:
        name: httpd
        state: started
        enabled: yes
    - name: index.html
      lineinfile:
        path: /var/www/html/index.html
        line: Waiting for content.
        create: yes
        owner: dba
        group: dba
        mode: 0600
        state: present

- hosts: dbservers
  become: true
  tasks:
    - name: create a user
      user:
        name: dba
        groups: dbaserver
        state: present
    - name: copy a file to dbaserver
      copy:
        src: /root/dbastuff.txt
        dest: /home/dba/dbastuff.txt
        owner: dba
        group: dba
        mode: 0600

- hosts: all:!admins
  become: true
  tasks:
    - name: install git
      yum:
        name: git
        state: present

- hosts: all
  become: true
  tasks:
    - name: install software
      yum:
        name: linuxacademy-backup-software
        state: installed
      ignore_errors: yes


CLOUD_GURU_LAB4
One of the tasks that you and your admin team does periodically is copy all of /var/log/messages from a remote server and pull it to a local machine for analysis. Rather than doing it manually you'd like to have Ansible do it.
Write a script that will use tar to compress /var/log/messages on a remote server and then copy that tar file to /tmp/messages/ on the Ansible Host.

vim messages.sh
#!/bin/bash
for i in dbserver1 webserver1 adminserver1;
do ssh ansible@$i "sudo tar -czf /tmp/messages.tar.gz /var/log/messages";
done
ansible all -m fetch -a "src=/tmp/messages.tar.gz dest=/tmp/messages"
~
~

FIREWALLd 
---
- name: firewalld rich rules
  hosts: vmservers
  become: yes
  tasks:
    - name: enable http https
      firewalld:
        zone: public
        service: "{{ item }}"
        permanent: yes
        immediate: yes
        state: disabled
      loop:
        - http
        - https
    - name: add port 8080-8084
      firewalld:
        zone: public
        port: 8080-8084/tcp
        permanent: yes
        immediate: yes
        state: disabled
    - name: add rich rule
      firewalld:
        zone: public
        rich_rule: rule family=ipv4 forward-port port=443 protocol=tcp to-port=8443
        permanent: yes
        immediate: yes
        state: disabled

~
~
:%s/enabled/disabled/g




---
- name: file,lineinfile,copy,replace
  hosts: node1
  tasks:
    - name: touch a new file
      file:
        path: /tmp/testfilecloud1
        state: touch
      tags: file1
    - name: add line with copy
      copy:
        content: added by copy module
        dest: /tmp/testfilecloud2
      tags: file2
    - name: line in file
      lineinfile:
        path: /tmp/testfilecloud3
        line: added by lineinfile module
        create: yes
      tags: file3

    - name: replace a line in testfile2
      replace:
        path: /tmp/testfilecloud2
        regexp: '^added.*$'
        replace: "line replaced by replace module"
    - name: replace a line in testfile3
      lineinfile:
        path: /tmp/testfilecloud3
        regexp: '.module$'
        line: "line replaced by lineinfile module"




CLOUD_GURU_LAB8.1
Ensure Ports 80 and 22 Are Open on Webservers
Ensure Ports 5432 and 22 Are Open on dbservers
Enable SELinux on All Servers

--
- name: setup firewalls on webservers
  become: yes
  hosts: webservers
  tasks:
    - name: firewalld
      firewalld:
        service: "{{ item }}"
        permanent: yes
        immediate: yes
        state: enabled
      loop:
        - ssh
        - http
- hosts: dbservers
  become: yes
  tasks:
    - name: firewalld
      firewalld:
        service: ssh
        immediate: yes
        permanent: yes
        state: enabled
    - name: firewall
      firewalld:
        service: postgresql
        immediate: yes
        permanent: yes
        state: enabled
- hosts: all
  become: true
  tasks:
    - name: selinux
      selinux:
        policy: targeted
        state: enforcing



CLOUD_GURU_LAB8.2
You received a ticket to upgrade the application and database for servers in your environment. There is an index.html and deploy.sh script in the /root directory on your Ansible Host. Write a playbook that deploys the index.html file to the webserver (in /var/www/html/), then deploys deploy.sh script to the dbserver in /opt, and finally executes that deploy.sh script. Use curl to test your deployment.

Once that deployment has finished, your developers let you know they found and fixed a major bug, and this fix needs to be deployed immediately. Deploy the /root/index2.html file to address this issue.
---
- name: deploy
  hosts: webserver
  become: yes
  tasks:
    - name: index.html
      copy:
        src: /root/index.html
        dest: /var/www/html/index.html
        owner: apache
        group: apache
        mode: 0644
- hosts: dbservers
  become: yes
  tasks:
    - name: deploy.sh
      copy: /root/deploy.sh
        owner: root
        group: root
        mode: 0755

    - name: run deploy
      shell: sh /root/deploy.sh

~
~

CLOUD_LAB_VAULT
Our database administrators have started using a third party tool to run some analysis on their database. This tool needs access to the password used by the dba account. We've been given the database password to enable this tool. Our task is to put that password in /home/dba/.pgpass but make sure that no one (without the vault password) can read the password on our local filesystem. The password is LinuxAcad. The file must be owned by the dba user and have a mode of 0600.

---
- name: dbapassword
  hosts: dbservers
  tasks:
    - name: dbpass
      lineinfile:
        line: "LinuxAcad"
        create: yes
        owner: dba
        group: dba
        mode: 0600
        path: /home/dba/.pgpass

ansible-vault encrypt dppass.yml



ADVANCE AUTOMATION lab
There are 2 tasks to accomplish for this hands-on lab.
Modify that playbook to populate the /opt/backup/streams file with the value of the host based-variable from the Ansible inventory file.

inventory.ini

---
- name: install csh
  hosts: backup_servers
  become: true
  tasks:
    - name: create path
      file:
        path: /opt/backup
        state: directory
    - name: var in file
      copy:
        path: /opt/backup/streams
        content: "{{ streams }}"
        state: present
~
CONFIGURE ansible.cfg
[defaults]
inventory=/home/ansible/ansible/inventory
roles_path=/home/ansible/ansible/roles
remote_user=bob
ask_pass=false
host_key_checking=false
[privilegeescalation]
become=true
become_user=root
become_method=sudo
become_ask_pass=false


Create a file called packages.yml in /home/sandy/ansible to install some packages for the following
hosts. On dev, prod and webservers install packages httpd, mod_ssl, and mariadb. On dev only install the
development tools package. Also, on dev host update all the packages to the latest.
---
- name: Create a file called packages.yml in /home/sandy/ansible to install some packages for the following hosts. On dev, prod and webservers install packages httpd, mod_ssl, and mariadb. On dev only install the development tools package. Also, on dev host update all the packages to the latest.
  hosts: dev,test,webservers
  become: true
  tasks:
    - name: install 3 packages
      yum:
        name:
          - httpd
          - mod_ssl
          - mariadb
        state: present

    - name: install development package
      yum:
        name: '@Development tools'
        state: present
      when: 'dev' in group_names
    - name: update all packages
      yum:
        name: '*'
        state: latest
      when: 'dev' in group_names
~
~

"*************************************************************************"
CLOUD_LAB 
#BACKUP.YML
---
- hosts: all
  become: yes
  tasks:
    - name: create backup directories
      file:
        path: /mnt/backup_vol/{{ ansible_hostname }}
        state: directory
      tags:
        - hostvar
        - webservervars
        - mediavars
- hosts: web1
  become: yes
  tasks:
    - name: backup scripts
      archive:
        dest: /mnt/backup_vol/{{ ansible_hostname }}/scripts.tgz
        path: "{{ script_files }}"
      tags: hostvar

- hosts: webservers
  become: yes
  tasks:
    - name: backup httpd configs
      archive:
        dest: /mnt/backup_vol/{{ ansible_hostname }}/httpd_configs.tgz
        path: "{{ httpd_config }}"
      tags: webservervars
    - name: backup webroot
      archive:
        dest: /mnt/backup_vol/{{ ansible_hostname }}/httpd_webroot.tgz
        path: "{{ httpd_webroot }}"
      tags: webservervars

- hosts: media
  become: yes
  tasks:
    - name: backup media content
      archive:
        dest: /mnt/backup_vol/{{ ansible_hostname }}/media_content.tgz
        path: "{{ media_content }}"
      tags: mediavars
    - name: backup media index
      archive:
        dest: /mnt/backup_vol/{{ ansible_hostname }}/media_index.tgz
        path: "{{ media_index }}"
      tags: mediavars


#!/bin/sh

# Need to take a tag varialbe
# mediavars to test media
# webservervars to test webservers
# hostvar to test host var
# use playbook tags maybe?

script to run multiple playbooks


case "$1" in
  mediavars)
    ansible-playbook -i /home/ansible/inventory /home/ansible/scripts/backup.yml --tags "mediavars"
    exit $?
    ;;
  webservervars)
    ansible-playbook -i /home/ansible/inventory /home/ansible/scripts/backup.yml --tags "webservervars"
    exit $?
    ;;
  hostvar)
    ansible-playbook -i /home/ansible/inventory /home/ansible/scripts/backup.yml --tags "hostvar"
    exit $?
    ;;
  *)
    ansible-playbook -i /home/ansible/inventory /home/ansible/scripts/backup.yml
    exit $?
esac


******SOLUTION*******
vim /home/ansible/inventory
[media]
media1
media2
[webservers]
web1
web2

$ mkdir host_vars -> vim web1 
script_files: /tmp/usr/local/scripts

$ mkdir group_vars -> vim media 
media_content: /tmp/var/media/content
media_index: /tmp/opt/media/mediaIndex

$ mkdir group_vars -> vim webservers 
httpd_webroot: /var/www
media_index: /etc/httpd


# "**********************************************************************"
# Summary tasks list:

# Create an inventory in /home/ansible/inventory containing a host group named web. The web group should contain node1 and node2.
# Create a playbook in /home/ansible/web.yml.
# Configure the playbook to install httpd on the web group.
# Configure the playbook to start and enable the httpd service on the web group.
# Configure the playbook to retrieve the website from http://repo.example.com/website.tgz on each server in the web group.
# Configure the playbook to unarchive the website into /var/www/html on all servers in the web group.
# Execute the playbook you created using the inventory you created to verify your work.
---
- name: install website
  hosts: web
  become: true
  tasks:
    - name: install httpd
      yum:
        name: httpd
        state: present
    - name: enable
      service:
        name: httpd
        state: started
        enabled: true
    - name: url
      get_url:
        url: http://repo.example.com/website.tgz
        dest: /tmp/website.tgz
    - name: unarchive
      unarchive:
        remote_src: yes
        src: /tmp/website.tgz
        dest: /var/www/html

"*******************************************************""

Create a playbook: `/home/ansible/report.yml`

Configure the Playbook to Download *http://apps.l33t.com/transaction_list* to `/home/ansible/transaction_list` on `localhost` and Outputs the Message "File downloaded." to `stdout`

Configure the Playbook to Handle Connection Failure by Outputting "l33t.com appears to be down. Try again later." to `stdout`

Configure the Playbook to Output "Attempt Completed" to `stdout`, Whether It Was Successful or Not

Configure the Playbook to Replace All Instances of `#BLANKLINE` with the Line Break Character `\n`

Verify Configuration by Running the Playbook

wrong method
# ---
# - name: download file
#   hosts: localhost
#   become: true
#   tasks:
#     - name: download
#       get_url:
#         url: http://apps.l33t.com/transaction_list
#         dest: /home/ansible/transaction_list
#       register: download
#     - debug:
#         msg: "{{ download }}"
#       when: download.changed == true
#     - debug:
#         msg: "l33t.com appears to be down. Try again later"
#       when: download.failed == true
#     - debug:
#         msg: "The attempt completed successfully"
#       when: download.exist == true

right method
---
- name: download file
  hosts: localhost
  become: true
  tasks:
    - name: block example
      block:
        - name: download
          get_url:
            url: http://apps.l33t.com/transaction_list
            dest: /home/ansible/transaction_list
        - debug:
            msg: "File Downloaded"
      rescue:
        - debug:
            msg: "l33t.com appears to be down. Try again later"
      always:
        - debug:
            msg: "The attempt completed successfully"
~
~
~
~
~THIS SCRIPT CHANGES DOWNLOAD BEHAVIOR

#!/bin/sh

# Remove transaction_list, otherwise playbook will not check url again.
rm -f /home/ansible/transaction_list > /dev/null;

# Is httpd running?
nc -z -w 50ms apps.l33t.com 80 > /dev/null


# Switch states depending on if it is up or down
if [ $? -ne 0 ];
then
  echo -n "Starting apps.l33t.com...";
  ansible node1 -b -m service -a "name=httpd state=started" > /dev/null;
  echo "done."
else
  echo -n "Stopping apps.l33t.com...";
  ansible node1 -b -m service -a "name=httpd state=stopped" > /dev/null;
  echo "done."
fi


"*******************************************************"
Create a Template *sudoers* File in `/home/ansible/hardened.j2` That Produces a File with Appropriate Output for Each Host

The Deployed File Should Resemble the Example File Except with the *IP* and *hostnames* Customized Appropriately

Create a Playbook in `/home/ansible/security.yml` That Uses the Template Module to Deploy the Template on All Servers in the Default Ansible Inventory After Validating the Syntax of the Generated File

Run the Playbook and Ensure the Files Are Correctly Deployed

Grant users in the sysops group the ability to run all commands as root for each local system by IP address. This would be what the entry in your result file except with the target system's IP: 
%sysops 34.124.22.55 = (ALL) ALL.
Define the host_alias group WEBSERVERS to contain all servers in the ansible web inventory group:
Host_Alias WEBSERVERS = <host name>
Define the host_alias group DBSERVERS to contain all servers in the ansible database inventory group: 
Host_Alias DBSERVERS = <host name>
Grant users in the httpd group the ability to sudo su - webuser on the WEBSERVERS hosts: 
%httpd WEBSERVERS = /bin/su - webuser
Grant users in the dba group sudo su - dbuser on the DBSERVERS hosts: 
%dba DBSERVERS = /bin/su - dbuser
The file must be validated using /sbin/visudo -cf before deployment.

vim `/home/ansible/hardened.j2
%sysops {{ ansible_default_ipv4.address }} = (ALL) ALL
Host_Alias WEBSERVERS = {{ groups['web']|join(' ') }}
Host_Alias DBSERVERS = {{ groups['database']|join(' ') }}
%httpd WEBSERVERS = /bin/su - webuser
%dba DBSERVERS = /bin/su - dbuser


---
- name: copy template
  hosts: all
  become: true
  tasks:
    - name: copy template
      template:
        src: /home/ansible/hardened.j2
        dest: /etc/sudoers.d/hardened
        validate: /sbin/visudo -cf %s
# crucial to validate or sudo will break on target